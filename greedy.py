# greedy algorithm: only select the best options in every current situation.

# 문제: [거스름 돈] 카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재한다고 가정. 
# 손님에게 거슬러 주어야 할 돈이 N원일 때 거슬러 주어야 할 동전의 최소 개수를 구하시오. 단, 거슬러 줘야 할 돈 N은 항상 10의 배수

# 풀이 접근: 가장 큰 화폐 단위인 500원을 먼저 사용하면서 돈을 거슬러 주면 된다.

# ex) N = 1,260 -> 500 * 2, 100 * 2, 50 * 1, 10 * 1 (6개)

# 정당성 분석: 가장 큰 화폐 단위부터 사용하는것이 최적의 해를 보장하는 이유는? -> 가지고 있는 동전중에서 큰 단위가 항상 작은 단위의 배수이므로
#           작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문이다. 
#           만약에 800원을 거슬러 주어야 하는데 화폐 단위가 500, 400, 100이라면? 위 알고리즘을 따라가다 보면 500 * 1, 100 * 3 가 될것
#           하지만 최적의 해는 400 * 2 이므로 위와같은 환경에서는 이 알고리즘이 알맞지 않다. (500원이 400원의 배수가 아니므로)


n = 1260
count = 0

array = [500, 100, 50, 10]

for coin in array: 
    count += n // coin
    n %= coin

print(count)

# 문제: [1이 될때까지] 어떠한 수 N이 1이 될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 한다. 단, 두번째 연산은 N이 K로 나누어 덜어질
# 때만 선택할 수 있다. N과 K가 주어질 때 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 최소 횟수를 구하는 프로그램을 작성해라.

# 1. N에서 1을 뺀다
# 2. N을 K로 나눈다. 


n, k = map(int, input().split())
count = 0

while True:
    target = (n // k) * k # n에 가장 근접한 k의 배수를 탐색
    count += n - target
    n = target

    # 더이상 n을 k로 나눌 수 없을때; 나누기 전에 이 조건을 확인을 해야함
    if n < k:
        break

    n //= k
    count +=1

# n이 k보다 작을경우 이 부분으로 넘어옴. 1이 남을때 까지 1을 빼는 연산을 해야 하므로
count += (n - 1)
print(count)

# 매번 n을 확인하여 연산을 하는 방법으로 코드를 짤 수 있지만, 위 코드처럼 짜게 되면 log 시간 복잡도를 가지게 되므로 더욱 효과적.


# 문제: [곱하기 혹은 더하기] 각 자리가 숫자 (0부터 9)로만 이루어진 문자열 S가 주어졌을 때, 왼쪽부터 오른쪽으로 하나씩 모든
#       숫자를 확인하며 숫자 사이에 'x' 혹은 '+' 연산자를 넣어 결과적으로 만들어질 수 있는 가장 큰 수를 구하는 프로그램을 작성해라
#       단 +보다 x를 먼저 계산하는 일반적인 방식과는 달리, 모든 연산은 왼쪽에서부터 순서대로 이루어 진다고 가정.

# 두 수에 대하여 연산을 수행할 때, 두 수 중에서 하나라도 1 이하인 경우에는 더하며, 두 수가 모두 2 이상인 경우에는 곱하면 됨.

data = input()

# 데이터의 맨 앞자리 값으로 result값을 초기화
result = int(data[0])

for i in range(1, len(data)):
    num = int(data[i])
    # 두 수 중에서 하나라도 0이나 1인 경우 더하기를 수행
    if num <= 1 or result <= 1:
        result += num
    else:
        result *= num

print(result)




